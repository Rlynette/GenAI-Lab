from pathlib import Path
import os
import shutil
import subprocess
import uuid
import datetime
from typing import Dict, Any

# Optional GitPython
try:
    from git import Repo, GitCommandError
except Exception:
    Repo = None
    GitCommandError = Exception

def _unique_dest(dest_parent: Path, repo_name: str) -> Path:
    ts = datetime.datetime.utcnow().strftime("%Y%m%d%H%M%S")
    suffix = uuid.uuid4().hex[:6]
    return dest_parent / f"{repo_name}-{ts}-{suffix}"

def clone_repo(url: str, dest_parent: str = "tmp_clones", shallow: bool = True, timeout: int = 300) -> str:
    final_url = (url or "").strip() or os.environ.get("REPO_URL", "").strip()
    if not final_url:
        raise RuntimeError("No repo URL provided and REPO_URL env var is not set.")

    dest_parent_p = Path(dest_parent)
    dest_parent_p.mkdir(parents=True, exist_ok=True)

    repo_name = Path(final_url.rstrip("/")).name or "repo"
    dest = dest_parent_p / repo_name

    # If dest exists, create unique destination to avoid clone collisions
    if dest.exists():
        dest = _unique_dest(dest_parent_p, repo_name)

    try:
        if Repo is None:
            cmd = ["git", "clone"]
            if shallow:
                cmd += ["--depth", "1"]
            cmd += [final_url, str(dest)]
            subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout)
        else:
            if shallow:
                Repo.clone_from(final_url, str(dest), depth=1)
            else:
                Repo.clone_from(final_url, str(dest))
        return str(dest)
    except Exception as e:
        try:
            if dest.exists():
                shutil.rmtree(dest)
        except Exception:
            pass
        stderr_text = ""
        if hasattr(e, "stderr") and e.stderr:
            stderr_text = e.stderr.decode(errors="ignore") if isinstance(e.stderr, (bytes, bytearray)) else str(e.stderr)
        raise RuntimeError(f"git clone failed for url={final_url!r}. stderr: \n  stderr: {stderr_text}") from e

def file_tree(root: str, depth: int = 2) -> Dict[str, Any]:
    def _walk(p: Path, d: int):
        if d < 0:
            return {}
        if p.is_file():
            return {}
        children = {}
        for c in sorted(p.iterdir()):
            if c.is_dir():
                children[c.name] = {"type": "dir", "children": _walk(c, d-1)}
            else:
                children[c.name] = {"type": "file"}
        return children

    p = Path(root)
    return {p.name: {"type": "dir", "children": _walk(p, depth-1)}}
